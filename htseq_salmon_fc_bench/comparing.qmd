---
title: "Hackaton_preparation_and_templates"
format: html
editor: visual
---

```{r}
# library(DESeq2)
# library(clusterProfiler)
# library(WGCNA)
# library(IRanges)
# library(tximport)
library(edgeR)
library(tidyverse)
library(EDASeq)
library(clusterProfiler)
library(org.Mm.eg.db)
library(IOBR)
```

# Стратегия проверки

1. Прочитать метадату, выкинуть NA (есть)
2. Отфильтровать по каунтам HTSEQ (есть)
2.1 Выкинуть образцы HTSEQ из FC и salmon (сделаем на этапе корреляции)
2.2 Фильтровать по отсечке для каждого типа подсчета каунтов 
3. Сравнить полученные матрицы сырых ридов между собой
3.1 Пирсоновская корреляция на общем датасете (без нулей везде)
3.2 Пирсоновская корреляция на датасете, с максимальным удалением образцов
4. Посмотреть на ДЭ, сравнить разные эксперименты (направление ДЭ, логфолчендж для разных генов)

> TODO Фильтрация как в статье
> DE пан-тишью и потканевая
> Меры отличия: 
- количество выпадающих образцов (фильтр по образцам)
- количество выпадающих генов (фильтр по генам и спецфильтр по генам)
- дифэкспрессия

> Попробовать функцию count2tpm для перевода в тпмы

> Для исследования с фильтром как в статье -- отличия стабильных генов.

> Для гитхаба -- зафиксировать версии пакетов

Итого 18 DE на 2 вида фильтрации и 3 типа пайплайнов (108)

> Подготовить генерацию констрастов

## Метаданные и расклады

Добавляем возрастуню группу, как в оригинальной статье

## Таблица с каунтами

##### Оценить распределение для потранскриптного салмона

```{r}
# Читаем каунты
htseq_raw <- read.csv("htseq/old_counts.csv")
# Присваиваем имена генов
gene_names <- htseq_raw[[1]]
# Правим имена образцов
colnames(htseq_raw) <- colnames(htseq_raw) |> str_split_i("\\.", 1)
# Даем рядам имена генов
rownames(htseq_raw) <- gene_names
```

```{r}
# Читаем каунты
salmon_counts <- read.csv("salmon/counts_raw.csv")
# Присваиваем имена генов
gene_names <- salmon_counts[[1]]
# Даем рядам имена генов
rownames(salmon_counts) <- gene_names
```


```{r}
# Читаем каунты
salmon_gene_counts <- read.csv("salmon/gene_counts_raw.csv")
# Присваиваем имена генов
gene_names <- salmon_gene_counts[[1]]
# Даем рядам имена генов
rownames(salmon_gene_counts) <- gene_names
```

Смотрим на распределение
```{r}
create_counts_distribution <- function(raw_counts_df){
  total_counts <- raw_counts_df |> 
    summarise(across(where(is.numeric), ~ sum(.x)))
  
  samples <- total_counts |> t() |> rownames()
  counts <- total_counts |> t()
  
  df_for_filt <- tibble(
    sample = samples,
    counts = counts
  )
  
  return(df_for_filt)
}

salmon_total_tr_counts <- create_counts_distribution(salmon_counts)
salmon_total_gene_counts <- create_counts_distribution(salmon_gene_counts)
htseq_total_counts <- create_counts_distribution(htseq_raw)
```

Фильтруем по оригинальной отсечке 

> TODO Сделать relative-отсечку

```{r}
salmon_total_filtered_samples <- salmon_total_tr_counts |> 
  filter(counts > 5000000) |> 
  pull(sample)
htseq_total_filtered_samples <- htseq_total_counts |> 
  filter(counts > 5000000)|> 
  pull(sample)
salmon_total_filtered_gene_samples <- salmon_total_gene_counts |> 
  filter(counts > 5000000) |> 
  pull(sample)
```

### Расчет метаданных

```{r}
# Читаем метаданные
metad <- read_csv("metadata.csv")
# Создаем функцию с вектором группы
create_condition_vector <- function(metad, filtered_names, target_vector){
  metad |> 
    filter(`Sample name` %in% filtered_names) |> 
    pull(target_vector)
}

# Добавляем возрастную группу и тип ткани, как в оригинальной статье
metad <- metad |> 
  mutate(
    age_group_article = case_when(
      `characteristics: age` == "1" ~ "adolescent",
      `characteristics: age` %in% c("3", "6") ~ "young",
      `characteristics: age` %in% c("9", "12", "15") ~ "middle_aged",
      # Авторы не написали, к какой группе относятся 18-месячные мыши
      `characteristics: age` %in% c("18", "21", "24", "27") ~ "old"
    ) |> as.factor() |> fct_relevel("adolescent", "young", "middle_aged", "old"),
    `characteristics: age` = `characteristics: age` |> as.factor() |> fct_relevel(c("1", "3", "6", "9", "12", "15", "18", "21", "24", "27")),
    tissue = `source name` |> str_split_i("_[:digit:]", 1)
  )

htseq_ages <- create_condition_vector(metad, htseq_total_filtered_samples, "characteristics: age")
salmon_ages <- create_condition_vector(metad, salmon_total_filtered_samples, "characteristics: age")
```

Сохраняем промежуточный результат
```{r}
save.image("pre_tmm_stage.RData")
```


## Генерируем TMM

### Стандартный подход

```{r}
tmm_creator <- function(raw_counts_df, filtered_samples, grouping_vector){
  raw_counts_df <- raw_counts_df[, filtered_samples]
  edge_dge <- DGEList(counts=raw_counts_df, group=grouping_vector)
  # Фильтруем по генам
  keep <- filterByExpr(edge_dge, group=grouping_vector)
  edge_dge <- edge_dge[keep,,keep.lib.sizes=FALSE]
  # Делаем TMM
  edge_dge <- normLibSizes(edge_dge, method = "TMM")
  return(edge_dge)
}

tmm_htseq <- tmm_creator(htseq_raw, htseq_total_filtered_samples, htseq_ages)
tmm_salmon_tr <- tmm_creator(salmon_counts, salmon_total_filtered_samples, salmon_ages)
tmm_salmon_genes <- tmm_creator(salmon_gene_counts, salmon_total_filtered_samples, salmon_ages)
```

### Подход из статьи

```{r}
# tmm_creator_article <- function(raw_counts_df, filtered_samples, grouping_vector){
#   raw_counts_df <- raw_counts_df[, filtered_samples]
#   edge_dge <- DGEList(counts=raw_counts_df, group=grouping_vector)
#   # Фильтруем по генам, убираем только нулевую экспрессию
#   keep <- filterByExpr(edge_dge, group=grouping_vector, min.count=1)
#   
# }
```


### TMM для Эржены в csv

```{r}
tmm_for_ergena <- function(tmm_df, output_name){
  features <- tmm_df@.Data[[1]] |> rownames()
  main_data <- tmm_df@.Data[[1]] |> as.data.frame()
  main_data <- main_data |> 
    mutate(
      feature = features, .before = 1
    )
  write_csv(main_data, paste0("tmm_filtered_", output_name, ".csv"))
}

tmm_for_ergena(tmm_htseq, "htseq")
tmm_for_ergena(tmm_salmon_genes, "salmon_genes")
tmm_for_ergena(tmm_salmon_tr, "salmon_trs")
```


## Генерируем TPM

Расчет длины генов

```{r}
# # Переводим айдишники в энсембл при необходимости
# htseq_genes_mgi <- rownames(htseq_raw)
# htseq_genes <- birt(htseq_genes_mgi, fromType = "SYMBOL", toType = "ENSEMBL", OrgDb = "org.Mm.eg.db")
# salmon_genes <- rownames(salmon_gene_counts)
# # Расчитываем длину генов
# htseq_length <- getGeneLengthAndGCContent(htseq_genes, "mmu", mode=c("biomart", "org.db"))
# salmon_length <- getGeneLengthAndGCContent(salmon_genes, "mmu", mode=c("biomart", "org.db"))
```

Функия для TPM

```{r}
# tpm_counter <- function(counts_df, length_vector){
#   # Псевдокод!
#   big_dataset <- left_join(length_vector, counts_df, by = var(""))
#   big_dataset |> 
#     mutate(
#       across(where(is.numeric(), ~ ))  # Убрать длину и гц из оценки
#     )
# }
tpm_counter2 <- function(counts_df, filtered_samples, symbol="Ensembl"){
  counts_df <- counts_df[, filtered_samples]
  tpm_matrix <- count2tpm(countMat = counts_df, idType = symbol, org = "mmus")
  tpm_matrix <- tpm_matrix |> 
    mutate(feature = rownames(tpm_matrix), .before = 1)
  
  return(tpm_matrix)
}

# Salmon
tpm_salmon_gene <- tpm_counter2(salmon_gene_counts, salmon_total_filtered_samples)
write_csv(tpm_salmon_gene, "tpm_salmon_gene.csv")

# Htseq
tpm_htseq <- tpm_counter2(htseq_raw, htseq_total_filtered_samples, "Symbol")
sym_to_ens <- bitr(rownames(tpm_htseq), fromType = "SYMBOL", toType = "ALIAS", OrgDb = "org.Mm.eg.db") |> 
  rename(feature = "SYMBOL")
tpm_htseq <- tpm_htseq |> 
  left_join(sym_to_ens, by = "feature") |> 
  relocate("ALIAS", .after = feature)
write_csv(tpm_htseq, "tpm_htseq.csv")
```

## Генерируем таблицы ДЭ

```{r}
# TODO -- можем ли запихнуть выржаение в качестве аргумента?
de_simple_fit <- function(edge_df, group_vector){
  design <- model.matrix(~group_vector)
  edge_df <- estimateDisp(edge_df, design)
  fit <- glmFit(edge_df,design)
}

htseq_de_fit <- de_simple(tmm_htseq, htseq_ages)
# de_simple(tmm_salmon_tr, salmon_ages)
salmon_de_fit <- de_simple(tmm_salmon_genes, salmon_ages)

saveRDS(htseq_de_fit, "htseq_glm_fit.rds")
saveRDS(salmon_de_fit, "salmon_gene_glm_fit.rds")
```

```{r}
# saved_de <- readRDS("htseq_glm_fit.rds")
# typeof(saved_de)
# glmLRT(saved_de)
```


# Old pipeline

#### HTSEQ

Проверка на фильтрацию каунтов
```{r}
# htseq_total_counts <- htseq_raw |> 
#   summarise(across(everything(), ~ sum(.x)))
# 
# samples_ht <- htseq_total_counts |> t() |> rownames()
# counts_ht <- htseq_total_counts |> t()
# 
# ht_for_filt <- tibble(
#   sample = samples_ht,
#   counts = counts_ht
# )
# 
# good_ht_samples <- ht_for_filt |> 
#   filter(counts > 5000000) |> 
#   pull(sample)
```


```{r}
# Проверяем на наличие каунтов с нулевой экспрессией
# Делаем эджаровский объект
# edge_dge <- DGEList(counts=htseq_raw, group=age_group)
# # Проверяем, есть лм образцы с нулевой экспрессией
# null_lib <-(edge_dge@.Data[[2]][["lib.size"]] > 0)
# null_lib |> sum()
# 
# good_colnames <- colnames(htseq_raw[,null_lib])
# # Фильтруем
# htseq_raw <- htseq_raw[, good_colnames]
# age_group <- age_group[null_lib]
# # Делаем эджаровский объект снова
# edge_dge <- DGEList(counts=htseq_raw, group=age_group)
# # Фильтруем
# keep <- filterByExpr(edge_dge, group=age_group)
# edge_dge <- edge_dge[keep,,keep.lib.sizes=FALSE]
# # Делаем TMM
# edge_dge <- normLibSizes(edge_dge, method = "TMM")
# samples <- edge_dge@.Data[[1]] |> colnames()
# genes <- edge_dge@.Data[[1]] |> rownames()
# edge_dge@.Data[[1]] |> as.data.frame() |> write_csv("htseq_without_pre_filtering_tmm.csv")
# design <- model.matrix(~age_group)
# fit <- glmQLFit(edge_dge,design)
# qlf <- glmQLFTest(fit)
# topTags(qlf)
```


#### salmon

##### Поэкзонно

```{r}
# Читаем каунты
# salmon_counts <- read.csv("salmon/counts_raw.csv")
# # Присваиваем имена генов
# gene_names <- salmon_counts[[1]]
# # Убираем NA-ные образцы
# salmon_counts <- salmon_counts[, valid_names]
# # Даем рядам имена генов
# rownames(salmon_counts) <- gene_names
```

```{r}
# Проверяем на наличие каунтов с нулевой экспрессией
# Делаем эджаровский объект
# edge_sal <- DGEList(counts=salmon_counts, group=age_group)
# # Проверяем, есть лм образцы с нулевой экспрессией
# null_lib <-(edge_sal@.Data[[2]][["lib.size"]] > 0)
# 
# good_colnames <- colnames(salmon_counts[,null_lib])
# # Фильтруем
# salmon_counts <- salmon_counts[, good_colnames]
# age_group <- age_group[null_lib]
# # Делаем эджаровский объект снова
# edge_sal <- DGEList(counts=salmon_counts, group=age_group)
# # Фильтруем
# keep <- filterByExpr(edge_sal, group=age_group)
# edge_sal <- edge_sal[keep,,keep.lib.sizes=FALSE]
# # Делаем TMM
# edge_sal <- normLibSizes(edge_sal, method = "TMM")
# samples <- edge_sal@.Data[[1]] |> colnames()
# genes <- edge_sal@.Data[[1]] |> rownames()
# edge_sal@.Data[[1]] |> as.data.frame() |> write_csv("salmon_exon_without_pre_filtering_tmm.csv")
# saveRDS(edge_sal, "salmon_tmm.Rdata")
# design <- model.matrix(~age_group)
# fit <- glmQLFit(edge_sal,design)
# qlf <- glmQLFTest(fit)
# topTags(qlf)
```


##### Погенно



Проверка на фильтрацию каунтов
```{r}
# salmon_gene_total_counts <- salmon_gene_counts |> 
#   summarise(across(everything(), ~ sum(.x)))
# 
# samples_salmon <- salmon_gene_total_counts |> t() |> rownames()
# counts_salmon <- salmon_gene_total_counts |> t()
# 
# salmon_for_filt <- tibble(
#   sample = samples_salmon,
#   counts = counts_salmon
# )
# good_salmon_samples <- salmon_for_filt |> 
#   filter(counts > 5000000) |> 
#   pull(sample)
```


```{r}
# Проверяем на наличие каунтов с нулевой экспрессией
# Делаем эджаровский объект
# edge_gene_sal <- DGEList(counts=salmon_gene_counts, group=age_group)
# # Проверяем, есть лм образцы с нулевой экспрессией
# null_lib <-(edge_gene_sal@.Data[[2]][["lib.size"]] > 0)
# 
# good_colnames <- colnames(salmon_gene_counts[,null_lib])
# # Фильтруем
# salmon_gene_counts <- salmon_gene_counts[, good_colnames]
# age_group <- age_group[null_lib]
# # Делаем эджаровский объект снова
# edge_gene_sal <- DGEList(counts=salmon_gene_counts, group=age_group)
# # Фильтруем
# keep <- filterByExpr(edge_gene_sal, group=age_group)
# edge_gene_sal <- edge_gene_sal[keep,,keep.lib.sizes=FALSE]
# # Делаем TMM
# edge_gene_sal <- normLibSizes(edge_gene_sal, method = "TMM")
# samples <- edge_gene_sal@.Data[[1]] |> colnames()
# genes <- edge_gene_sal@.Data[[1]] |> rownames()
# edge_gene_sal@.Data[[1]] |> as.data.frame() |> write_csv("salmon_gene_without_pre_filtering_tmm.csv")
# saveRDS(edge_gene_sal, "salmon_tmm.Rdata")
# design <- model.matrix(~age_group)
# fit <- glmQLFit(edge_gene_sal,design)
# qlf <- glmQLFTest(fit)
# topTags(qlf)
```


#### FeatureCounts

```{r}
# Проверяем на наличие каунтов с нулевой экспрессией
# Делаем эджаровский объект
# edge_sal <- DGEList(counts=salmon_gene_counts, group=age_group)
# # Проверяем, есть лм образцы с нулевой экспрессией
# null_lib <-(edge_sal@.Data[[2]][["lib.size"]] > 0)
# 
# good_colnames <- colnames(salmon_gene_counts[,null_lib])
# # Фильтруем
# salmon_gene_counts <- salmon_gene_counts[, good_colnames]
# age_group <- age_group[null_lib]
# # Делаем эджаровский объект снова
# edge_sal <- DGEList(counts=salmon_gene_counts, group=age_group)
# # Фильтруем
# keep <- filterByExpr(edge_sal, group=age_group)
# edge_sal <- edge_sal[keep,,keep.lib.sizes=FALSE]
# # Делаем TMM
# edge_sal <- normLibSizes(edge_sal, method = "TMM")
# samples <- edge_sal@.Data[[1]] |> colnames()
# genes <- edge_sal@.Data[[1]] |> rownames()
# edge_sal@.Data[[1]] |> as.data.frame() |> write_csv("salmon_exon_without_pre_filtering_tmm.csv")
# saveRDS(edge_sal, "salmon_tmm.Rdata")
# design <- model.matrix(~age_group)
# fit <- glmQLFit(edge_sal,design)
# qlf <- glmQLFTest(fit)
# topTags(qlf)
```

